// protoc-gen-elixir-tesla is a plugin for the Protobuf compiler that generates
// Elixir Tesla client modules for making HTTP requests to gRPC services.
// To use it, build this program and make it available on your PATH as protoc-gen-elixir-tesla.
//
// The 'elixir-tesla' suffix becomes part of the arguments for the Protobuf
// compiler. To generate Tesla client modules using protoc:
//
//	protoc --elixir_out=gen --elixir-tesla_out=gen path/to/file.proto
//
// With [buf], your buf.gen.yaml will look like this:
//
//	version: v2
//	plugins:
//	  - local: protoc-gen-elixir
//	    out: gen
//	  - local: protoc-gen-elixir-tesla
//	    out: gen
//
// This generates Tesla client modules for the Protobuf services
// defined by file.proto. If file.proto defines the foov1 Protobuf package, the
// invocations above will write output to:
//
//	gen/path/to/foo_v1.pb.ex
//	gen/path/to/foo_v1_client.ex
//
// [buf]: https://buf.build
package main

import (
	"flag"
	"fmt"
	"os"
	"path"
	"path/filepath"
	"regexp"
	"strings"

	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/types/descriptorpb"
	"google.golang.org/protobuf/types/pluginpb"
)

const (
	filenameSuffix      = "_client.ex"
	clientSuffix        = "Client"
	defaultModuleSuffix = "Client"
	moduleSuffixFlagName = "module_suffix"

	usage = "\n\nFlags:\n  -h, --help\tPrint this help and exit.\n      --version\tPrint the version and exit."
)

func main() {
	if len(os.Args) == 2 && os.Args[1] == "--version" {
		if _, err := fmt.Fprintln(os.Stdout, "protoc-gen-elixir-tesla v1.0.0"); err != nil {
			os.Exit(1)
		}
		os.Exit(0)
	}
	if len(os.Args) == 2 && (os.Args[1] == "-h" || os.Args[1] == "--help") {
		if _, err := fmt.Fprintln(os.Stdout, usage); err != nil {
			os.Exit(1)
		}
		os.Exit(0)
	}
	if len(os.Args) != 1 {
		if _, err := fmt.Fprintln(os.Stderr, usage); err != nil {
			os.Exit(1)
		}
		os.Exit(1)
	}
	var flagSet flag.FlagSet
	moduleSuffix := flagSet.String(
		moduleSuffixFlagName,
		defaultModuleSuffix,
		"Generate modules with the given suffix. An empty suffix denotes to generate without suffix.",
	)
	protogen.Options{ParamFunc: flagSet.Set}.Run(
		func(plugin *protogen.Plugin) error {
			plugin.SupportedFeatures = uint64(pluginpb.CodeGeneratorResponse_FEATURE_PROTO3_OPTIONAL) | uint64(pluginpb.CodeGeneratorResponse_FEATURE_SUPPORTS_EDITIONS)
			plugin.SupportedEditionsMinimum = descriptorpb.Edition_EDITION_PROTO2
			plugin.SupportedEditionsMaximum = descriptorpb.Edition_EDITION_2024

			for _, file := range plugin.Files {
				if file.Generate {
					generateFile(plugin, file, *moduleSuffix)
				}
			}

			return nil
		},
	)
}

func generateFile(plugin *protogen.Plugin, file *protogen.File, moduleSuffix string) {
	if len(file.Services) == 0 {
		return
	}

	// For Elixir, we generate one file per service
	for _, service := range file.Services {
		generateServiceClient(plugin, file, service, moduleSuffix)
	}
}

func generateServiceClient(plugin *protogen.Plugin, file *protogen.File, service *protogen.Service, moduleSuffix string) {
	// Generate filename for Elixir module
	serviceName := toSnakeCase(service.GoName)
	filename := serviceName + filenameSuffix
	
	generatedFile := plugin.NewGeneratedFile(filename, "")
	
	// Generate Elixir module
	moduleName := toPascalCase(service.GoName) + moduleSuffix
	
	// File header
	generatedFile.P("# Code generated by protoc-gen-elixir-tesla. DO NOT EDIT.")
	generatedFile.P("#")
	generatedFile.P("# Source: ", file.Desc.Path())
	generatedFile.P()
	
	// Module definition
	generatedFile.P("defmodule ", moduleName, " do")
	generatedFile.P("  @moduledoc \"\"\"")
	generatedFile.P("  Tesla client for ", service.GoName, " service.")
	generatedFile.P("  \"\"\"")
	generatedFile.P()
	
	// Generate functions for each method
	for _, method := range service.Methods {
		generateClientMethod(generatedFile, file, service, method)
	}
	
	generatedFile.P("end")
}

func generateClientMethod(g *protogen.GeneratedFile, file *protogen.File, service *protogen.Service, method *protogen.Method) {
	methodName := toSnakeCase(method.GoName)
	inputTypeName := getElixirTypeName(method.Input)
	
	// Generate method documentation if available
	if method.Comments.Leading.String() != "" {
		g.P("  @doc \"\"\"")
		g.P("  ", strings.TrimSpace(method.Comments.Leading.String()))
		g.P("  \"\"\"")
	}
	
	// Generate method signature and body
	g.P("  def ", methodName, "(client, %", inputTypeName, "{} = req, opts \\\\ []) do")
	
	// Generate URL path
	servicePath := "/" + strings.ToLower(file.Desc.Package().String()) + "." + service.GoName
	methodPath := "/" + method.GoName
	g.P("    url = \"", servicePath, methodPath, "\"")
	
	// Encode the request using Protobuf
	g.P("    body = Protobuf.encode(req)")
	
	// Make Tesla request
	g.P("    Tesla.post(client, url, body, opts)")
	g.P("  end")
	g.P()
}

// toSnakeCase converts PascalCase to snake_case
func toSnakeCase(s string) string {
	// Use regex to insert underscores before uppercase letters
	re := regexp.MustCompile("([a-z])([A-Z])")
	snake := re.ReplaceAllString(s, "${1}_${2}")
	return strings.ToLower(snake)
}

// toPascalCase converts snake_case to PascalCase
func toPascalCase(s string) string {
	if s == "" {
		return s
	}
	
	parts := strings.Split(s, "_")
	result := ""
	for _, part := range parts {
		if len(part) > 0 {
			result += strings.ToUpper(part[:1]) + strings.ToLower(part[1:])
		}
	}
	return result
}

// getElixirTypeName extracts the Elixir message type name from protobuf message
func getElixirTypeName(message *protogen.Message) string {
	// For now, just return the Go name - in real implementation,
	// this would need to map to the actual Elixir protobuf message names
	return message.GoIdent.GoName
}
